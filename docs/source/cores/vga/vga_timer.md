vga_timer documentation

A vga timer generates the timing signals h_sync and v_sync that are sent to the monitor. The three other signals (r, g, and b) are generated by separate logic which varies depending on what is displayed on the monitor. To assist this logic, the vga timer outputs video_on which tells the rgb controller that it can display. When video_on is 0, r, g, and b must also be 0.


```
....................................................._____
....................................................|.....|
....................................................|.....|
____________________________________________________|.....|_________

|--------------------a-----------------|-----b------|--c--|----d----|

a = display
b = front porch
c = sync pulse
d = back porch
```

The constant parameters for a, b, c, and d are given by the dictionary screen_constants found in _vga_constants.py

h_sync and v_sync both have an associated counter h and v, respectively. To get the correct timing for h_sync h counts through the section a, b, c, and d. Inside a video_on is 1. This section is equal to the 1920 horizontal pixels on a 1080p monitor. Section b is the front porch. This section is not displayed on screen, so video_on is 0. Section c is when h_sync is pulsed. The polarity of h_sync and v_sync vary depending on the resolution and frequency desired. Section d is the back porch which is the same as the front porch, but it occurs after h_sync is pulsed. All of the same occurs for v and v_sync except that v is only incremented when h overflows.

There is an extra parameter I added to the vga_timer. It is a tuple named edge_buffers and it contains four integers: left_buffer, right_buffer, top_buffer, and bottom_buffer. These are inputs which tell the vga timer how many pixels on the left, right, top, and bottom should be forced black by setting video_on to 0 when they should be displayed. Their implementation is very simple. Here's the modified timing diagram for h with the left and right buffers.

```
....................................................._____
....................................................|.....|
....................................................|.....|
____________________________________________________|.....|_________

|-lb-|---------------a-----------|--rb-|-----b------|--c--|----d----|

lb = left buffer
a = display
rb = right buffer
b = front porch
c = sync pulse
d = back porch
```

This makes the logic for video_on slightly more complicated since it has to check two bounds to see if it inside a instead of 1. To simplify it, we wrap the left buffer around to the end.

```
................................................_____
...............................................|.....|
...............................................|.....|
_______________________________________________|.....|______________

|---------------a-----------|--rb-|-----b------|--c--|----d----|-lb-|
```

a still has the same width and distance to c so the display will be the same as the previous timing diagram. The more import reason to keep a starting at 0 is the optional vga signals x and y. The signals h_sync, v_sync, and video_on  are necessary for interfacing with a monitor. x and y, on the other hand, may be used by combinatorial logic to generate r, g, and b. x and y are the values of the counters h and v while the display is on. If a starts at 0 on h and v, then the logic for computing x and y is just a truncation. Two more optional vga signals are h_refresh and v_refresh. These signals pulse once when h and/or v overflow. h_refresh and v_refresh can be used for outside logic to  synchronize with the vga timer.

One example is dividing y by an odd number, d.  Division logic is normally very expensive resource wise. Instead, two chained  counters can be used. The first counts from 0 to d and the second counts when the first overflows. These two counters correspond to y mod d and y div d. The resources used for two counters is also much less than a divider.
